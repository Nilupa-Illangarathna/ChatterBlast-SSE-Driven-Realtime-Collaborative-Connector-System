Okay, now we have these things completed basically. Now a person can get into the system and create a room. So a new row will be created on the database named rooms and this row consists of all the details including the joining members as well. These joining members will be stored in the joiners entry column basically and as a JSON file. Then when it comes to the joiners side, the URL will be created and this URL can be shareable. Once this URL is shared, anyone who gets this URL can join into this room. So basically what they have to do is come to the init page and go to the join room and then they can specify their username and this URL and they can click. So basically if this person is a new joiner to this room, it is defined based on the username actually. He will be taken into the database and the JSON file will be updated, will append his name. Basically he will be added as a new member. At the same time, if the same name is available in the JSON file as a member, let's assume John is available in it and the joining person's name is John. In that particular case scenario, the system thinks that this is the same person and then he will be treated as that person. So all the messages that he sent previously will be taken to the back end and they will be shown in this UI of the joiner, basically join UI.tjs. So that is what we have already done so far. Basically we take the username and we consider that whether he's already a joined person or not and based on that we either take all the messages or we create the entry point for the user by adding him to the JSON file. But now what I want to do is basically I want to send a message from the user joiner site. For that, at the initial point, please change these both codes. When I enter a message into the text form field of this join UI.tjs and press the button to send it, that message should be taken to the back end and it should be printed on the back end itself on the console. So basically the server side console should print the whatever message I'm sending real time.



please specify the name with this message when you send it from the join-ui.ejs so the backend can realize who sent this. So it should have these detils as a array. first one is the username, second one is the url third one is the message. the url and the username means the once we used to rendere this page ok so they are already availble in this join-ui.ejs and you can just use them.

then print all 3 in the backend as a arrray. 




tHIS IS NOT ABOUT GETTING MESAGES ROM DATABSE. THIS IS ABOUT PUTTING MESSAGES INTO THE DATABASE FROM USER. SO CONSIDER SEPERATLY





<!-- views/join-ui.ejs -->
<!DOCTYPE html>
<html lang="en">
<head>
  <!-- ... (head section remains unchanged) ... -->
</head>
<body>
  <h1>Welcome <%= username %> to the Join UI</h1>
  
  <!-- Display User Details -->
  <h2>User Details:</h2>
  <p>Username: <%= username %></p>

  <!-- Display User Messages -->
  <h2>User Messages:</h2>
  <ul>
    <% userMessages.forEach((message) => { %>
      <li><%= message %></li>
    <% }); %>
  </ul>

  <!-- Messaging Form -->
  <form action="/send-join-message" method="POST">
    <label for="joinMessage">Enter Message:</label>
    <input type="text" id="joinMessage" name="joinMessage" required>
    <button type="submit">Send</button>
  </form>

  <!-- Display Join Messages -->
  <ul id="joinMessages">
    <% userMessages.forEach((message) => { %>
      <li><%= message %></li>
    <% }); %>
  </ul>

  <script>
    // Use Socket.IO to listen for real-time messages
    const socket = io();

    socket.on('join-message', (msg) => {
      const joinMessagesList = document.getElementById('joinMessages');
      const li = document.createElement('li');
      li.textContent = msg;
      joinMessagesList.appendChild(li);
    });
  </script>
</body>
</html>









// index.js
const express = require('express');
const { createServer } = require('http');
const { Server } = require('socket.io');
const { createClient } = require('@supabase/supabase-js');
const { v4: uuidv4 } = require('uuid');

const app = express();
const server = createServer(app);
const io = new Server(server);

const supabaseUrl = 'https://zqjmkicfcolipzkqvslv.supabase.co';
const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inpxam1raWNmY29saXB6a3F2c2x2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3MDg4NjA2MDYsImV4cCI6MjAyNDQzNjYwNn0.okYMPvmrR8ftOXIyHYIJ2DQ-Tk2ZfVZhHXMM6cBmaVk';
const supabase = createClient(supabaseUrl, supabaseKey);

app.set('view engine', 'ejs');
app.use(express.static('public'));
app.use(express.urlencoded({ extended: true }));

const port = process.env.PORT || 3000;

// gets
app.get('/', (req, res) => {
  res.render('init');
});

app.get('/create-room', (req, res) => {
  res.render('create-room');
});

app.get('/join-room', (req, res) => {
  res.render('join-room');
});

app.get('/admin-ui/:username', async (req, res) => {
  const { username } = req.params;

  // Check if the table exists, if not, create it
  await createTableIfNotExists(username);

  // Generate the URL for the created room
  const roomUrl = `http://localhost:3000/join-room?username=${username}&url=${username}`;

  res.render('admin-ui', { username, roomUrl });
});

app.get('/join-ui/:username', async (req, res) => {
  const { username } = req.params;

  // Check if the table exists, if not, redirect to an error page or handle accordingly
  const tableExists = await checkTableExists(username);
  if (!tableExists) {
    // Redirect to an error page or handle accordingly
    res.redirect('/');
    return;
  }

  try {
    // Fetch the room data for the specified username
    const { data: roomData, error: roomError } = await supabase
      .from('rooms')
      .select()
      .eq('room_creator_username', username)
      .single();

    if (roomError) {
      throw new Error(`Error fetching room data: ${roomError.message}`);
    }

    res.render('join-ui', { username, roomData });
  } catch (error) {
    console.error(error);
    res.status(500).send(`Error: ${error.message}`);
  }
});


app.post('/create-room', async (req, res) => {
  const { username } = req.body;

  // Generate a valid UUID for room_creator_id
  const roomCreatorId = uuidv4();

  // Create a row for the room with essential information
  const roomData = {
    room_url: `http://localhost:3000/join-room?username=${username}&url=${username}`,
    room_creator_username: username,
    room_creator_id: roomCreatorId,
    joiners: JSON.stringify({}), // Empty for now, will be updated when joiners join
  };

  // Store the room data in the Supabase table
  const { data: createdRoom, error } = await supabase
    .from('rooms')
    .upsert([roomData], { returning: ['*'] });

  if (error) {
    console.error(error);
    res.status(500).send('Error creating room');
    return;
  }

  // Redirect to admin UI with the generated URL
  res.redirect(`/admin-ui/${username}`);
});





  



app.post('/join-room', async (req, res) => {
  const { username, url } = req.body;

  try {
    // Get the existing room data using the room_url
    const { data: roomData, error: roomError } = await supabase
      .from('rooms')
      .select()
      .eq('room_url', url)
      .single();

    if (roomError) {
      throw new Error(`Error fetching room data: ${roomError.message}`);
    }

    // Parse the joiners column data
    const joinersData = JSON.parse(roomData.joiners);

    // Check if the username already exists in joinersData
    if (joinersData.hasOwnProperty(username)) {
      // If the username exists, retrieve messages
      const userMessages = joinersData[username].messages;

      // Render the join-ui.ejs with existing user data
      res.render('join-ui', { username, userMessages });
    } else {
      // If the username doesn't exist, create a new entry
      // Create a unique key for the new joiner
      const joinerKey = `${username}`;

      // Add the new joiner to the joinersData with an empty array for messages
      joinersData[joinerKey] = {
        joined_at: new Date().toISOString(),
        messages: ["Hello"],
      };

      // Update the joiners column in the Supabase table using the room_url
      const { data: updatedRoom, updateError } = await supabase
        .from('rooms')
        .update({ joiners: JSON.stringify(joinersData) }) // Update the joiners column
        .eq('room_url', url)
        .single();

      if (updateError) {
        throw new Error(`Error updating room data: ${updateError.message}`);
      }

      // Render the join-ui.ejs with new user data
      res.render('join-ui', { username, userMessages: [] });
    }
  } catch (error) {
    console.error(error);
    res.status(500).send(`Error: ${error.message}`);
  }
});










// Your Socket.IO logic and other routes...

async function createTableIfNotExists(table_name) {
    // Create the query to create a new table with a predefined schema
    const query = `CREATE TABLE IF NOT EXISTS ${table_name} (id SERIAL PRIMARY KEY, username TEXT NOT NULL, message TEXT NOT NULL)`;
  
    // Execute the query
    await supabase.rpc('create_new_table', { table_name: table_name });
  }
  

async function checkTableExists(table_name) {
  // Check if the table exists
  const { data, error } = await supabase
    .from('rooms')
    .select()
    .eq('room_name', table_name)
    .single();

  return data !== null;
}






const rooms = {}; // To store room data and socket connections

io.on('connection', (socket) => {
  console.log('A user connected');

  // Handle joining room
  socket.on('join-room', (data) => {
    const { room, username } = data;
    socket.join(room);

    // Store room data (removed table creation logic)

    // Broadcast to all clients in the room
    io.to(room).emit('message', `${username} has joined the room`);
  });

  // Handle sending messages
  socket.on('send-message', (data) => {
    const { room, username, message } = data;

    // Broadcast to all clients in the room
    io.to(room).emit('message', `${username}: ${message}`);
  });

  // Handle disconnect (removed unnecessary table handling)
});


// Add this route at the end of your existing routes
app.post('/send-join-message', async (req, res) => {
  const { username, joinMessage } = req.body;

  try {
    // Get the existing room data using the username
    const { data: roomData, error: roomError } = await supabase
      .from('rooms')
      .select()
      .eq('room_creator_username', username)
      .single();

    if (roomError) {
      throw new Error(`Error fetching room data: ${roomError.message}`);
    }

    // Parse the joiners column data
    const joinersData = JSON.parse(roomData.joiners);

    // Add the new message to the joiner's messages array
    joinersData[username].messages.push(`${username}: ${joinMessage}`);

    // Update the joiners column in the Supabase table using the room_creator_username
    const { data: updatedRoom, updateError } = await supabase
      .from('rooms')
      .update({ joiners: JSON.stringify(joinersData) }) // Update the joiners column
      .eq('room_creator_username', username)
      .single();

    if (updateError) {
      throw new Error(`Error updating room data: ${updateError.message}`);
    }

    // Broadcast the join message to all clients in the room
    io.to(username).emit('join-message', `${username}: ${joinMessage}`);

    res.redirect(`/join-ui/${username}`);
  } catch (error) {
    console.error(error);
    res.status(500).send(`Error: ${error.message}`);
  }
});


app.post('/send-message', async (req, res) => {
  const { username, message } = req.body;

  // Store the message in the Superbase table
  const { data, error } = await supabase
    .from(username)
    .upsert([{ username, message }], { returning: ['*'] });

  if (error) {
    console.error(error);
    res.status(500).send('Error storing message');
    return;
  }

  // Broadcast the message to all clients in the room
  io.to(username).emit('message', `${username}: ${message}`);

  res.redirect(`/admin-ui/${username}`);
});

server.listen(port, () => {
  console.log(`Server is running on http://localhost:${port}`);
});






pleaSse properly sstructure the sending message data. add the user's username and the url already having for the room. message is text form field content. then print it just after recival