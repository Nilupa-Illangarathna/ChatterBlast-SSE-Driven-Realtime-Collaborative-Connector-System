Okay, that is about the code that we worked on so far in this chat. Now I'm going to talk about the code that I gave recently related to the front-end that I've worked on. I'm thinking about connecting that with this particular back-end that we already

Okay, in that particular code related to the frontend that I gave recently, I'll explain what happens. The whole process is something like this. First, there's a sequence related to data creation mechanisms. That sequence consists of t-shirt sizes, sequence 1, sequence 2, Fibonacci, and a custom sequence creation using a comma-separated string. All those stuff are there. When the server is running, we can get to the port 3000, localhost, and we can access these particular options. Basically, the user interface, like that text is there, header1 text. Then, we can select which sequence type we want as a sequence selection bar. Then, below to that, there's a text form field to enter a number. So, we can add something like 100 or 50 or something, and we can press whatever the sequence we want, and that particular sequence will be generated. Below to that, once this particular sequence is generated, it will be taken again from the backend. Exactly, that is how it happens. Basically, when we enter a number on the text form field, and when we click on sequence, any of the sequence buttons, that particular number and the sequence type will be taken to the backend. Based on that, it will generate that particular sequence type. It releases Fibonacci and 100. At the backend, the Fibonacci 0 to 100 will be generated. That array will be sent back to the frontend, and using this particular array, a set of tiles will be populated as a list view, and on each of the tile, each of the values in the sequence will be shown. That is how it happens. Then, once a sequence is selected that way, we can press submit button. At that level, my idea is we submit this particular sequence to the backend after selection. So, basically, the admin can select a particular sequence, and he can send this to the backend.

Okay, actually, I'll explain the whole front-end first, then I'll show you the relationship between both codes. First, after submitting this subquest, my idea is this selected sequence is sent to the backend as an array. Maybe I wrote as an array, I'll explain how to generate the string. Then you should save that in the inner database, I'll explain that as well. Then you send that, this pressing this submit button means we have initialized all the things and we can start the room. So basically it goes, we selected the sequence. After pressing this submit button, this sequence will be taken to the backend and then

OK, after taking this sequence back to the backend, the leaderboard will be shown. In this leaderboard, what I want to show is the username with that message that he sent. We already did the implementation in the backend code that's related to this. When a new joiner joins in, a new entry on the joiners JSON will be created, as you know. So then an event will be triggered. In that particular case scenario, we broadcast all the data to all the pages. And then we conditionally, using URL, we drop non-related ones and only kept the corresponding room-related data packets. Then those data is related to this leaderboard part. So basically, leaderboard shows all the room-related people. So then once a particular new user joins in, in this particular event should occur. And that particular user should be shown on this particular leaderboard. And then once this person sends a message, we know that joiners JSON is updated. And then that particular event is triggered. And all the latest messages with this user's name will be broadcasted. And then after this broadcast occurs, corresponding leaderboard should be updated in this particular frontend code. That is my intended idea. Then after every people, everyone of this particular room sends a message, that means if the watered values of all the fields are true, not any of the values are in the false level, the calculate button will be enabled. Otherwise, it is always disabled in my frontend code. So once all the joined people send a vote, that means everyone is watered. So watered states of the whole set of joiners is true. In that scenario, this submit button, this calculate button is enabled. And we can press calculate.

Okay, after that read about these fully
Until everyone sends a message, basically everyone votes, we show only two columns, name and the voted state. We do not show the voted value to the user in my front-end code. That is the exact behavior that I want. Nothing should change. Then basically, once this person, everyone is voted, I told you, the Calculate button is enabled there. Once it is enabled, we can press that. So once it is pressed, right now we send a random number from the back-end and we show that. Instead, I'll explain in the correct process, I'll explain how to calculate that value. We send as the random number and also we reveal all the values. The voted values column is also added to the leaderboard. So once the Calculate button is pressed, all three columns will be shown. That is the behavior of the front-end code. Now let's talk about the overall development.


// index.js
const express = require('express');
const http = require('http');
const socketIO = require('socket.io');
const path = require('path');

const app = express();
const server = http.createServer(app);
const io = socketIO(server);

app.set('views', path.join(__dirname, 'views'));
app.set('view engine', 'ejs');

app.use(express.static(path.join(__dirname, 'public')));

let timer;

// Function to generate Fibonacci sequence
function generateFibonacci(count) {
  const sequence = [];
  let a = 0, b = 1;
  for (let i = 0; i < count; i++) {
    sequence.push(a);
    const temp = a;
    a = b;
    b += temp;
  }
  return sequence;
}

// Example sequences
const tShirtSizes = ['XXS', 'XS', 'S', 'M', 'L', 'XL', 'XXL'];
const fibonacci = generateFibonacci(13); 
const customSequence = 'Custom,Sequence,Option,4'.replace(/\s/g, '').split(',');

const sequences = [tShirtSizes, fibonacci, customSequence];

// Example joined people array
let joinedPeople = [
  { joinerName: 'John', joinerId: '1', voted: true, votedValue: '5' },
  { joinerName: 'Alice', joinerId: '2', voted: true, votedValue: '6' },
  { joinerName: 'Bob', joinerId: '3', voted: false, votedValue: '' },
  { joinerName: 'Eva', joinerId: '4', voted: false, votedValue: '' },
  { joinerName: 'Mike', joinerId: '5', voted: true, votedValue: '4' },
  { joinerName: 'Sophie', joinerId: '6', voted: true, votedValue: '3' },
];

// Function to log the data structure
function logDataStructure() {
  console.log('Current Data Structure:');
  console.log(joinedPeople);
}

app.get('/', (req, res) => {
  // Pass joinedPeople array to the frontend
  res.render('join-ui', { sequences, joinedPeople });
});

// Function to generate Sequence 1
function generateSequence1(count) {
  return Array.from({ length: count }, (_, i) => i + 1);
}

// Function to generate Sequence 2
function generateSequence2(count) {
  return Array.from({ length: count / 2 }, (_, i) => (i + 1) * 2);
}

// Handle user input for sequences
io.on('connection', (socket) => {
  console.log('A user connected');
  logDataStructure();

  socket.on('updateSequences', ({ type, inputValue }) => {
    console.log(`Received input from the frontend: Sequence Type: ${type}, Input Value: ${inputValue}`);
    
    let updatedSequence;

    switch (type) {
      case 'tShirtSizes':
        updatedSequence = tShirtSizes;
        break;
      case 'sequence1':
        const seq1Count = parseInt(inputValue, 10) || 10;
        updatedSequence = generateSequence1(seq1Count);
        break;
      case 'sequence2':
        const seq2Count = parseInt(inputValue, 10) || 10;
        updatedSequence = generateSequence2(seq2Count);
        break;
      case 'fibonacci':
        const fibonacciCount = parseInt(inputValue, 10) || 10;
        updatedSequence = generateFibonacci(fibonacciCount);
        break;
      case 'custom':
        // Split the custom input by commas, remove spaces, and create an array
        updatedSequence = inputValue.split(',').map(item => item.trim());
        break;
      default:
        updatedSequence = [];
    }

    io.emit('updatedSequence', updatedSequence);
    logDataStructure();
  });

  // Socket event to handle tile clicks
  socket.on('tileClicked', (clickedValue) => {
    console.log(`Tile clicked: ${clickedValue}`);
  });

  // Function to check if all users have voted
  function allVoted() {
    return joinedPeople.every(person => person.voted);
  }

  // Function to enable/disable the Calculate button based on voting states
  function updateCalculateButton() {
    const calculateButtonState = allVoted();
    io.emit('updateCalculateButton', calculateButtonState);
  }

  // Function to update the joinedPeople array
  function updateJoinedPeople() {
    // Check if the count is less than 10
    if (joinedPeople.length < 20) {
      const randomCount = Math.floor(Math.random() * 4) + 1;
      
      for (let i = 0; i < randomCount; i++) {
        // Add a new person with voted state set to false and votedValue empty
        joinedPeople.push({
          joinerName: `User_${joinedPeople.length + 1}`,
          joinerId: `${joinedPeople.length + 1}`,
          voted: false,
          votedValue: '',
        });
      }
      
      // If count is 10, update the Calculate button state
      if (joinedPeople.length === 10) {
        updateCalculateButton();
      }
    } else {
      // Set voted value to true and add a random number to a random person, only if not changed before
      const notChangedPeople = joinedPeople.filter(person => person.voted === false);
      
      if (notChangedPeople.length > 0) {
        const randomIndex = Math.floor(Math.random() * notChangedPeople.length);
        notChangedPeople[randomIndex].voted = true;
        notChangedPeople[randomIndex].votedValue = Math.floor(Math.random() * 10) + 1;

        // Check if all voted values are true and not empty
        if (allVoted()) {
          updateCalculateButton();
        }
      }
    }

    // Broadcast the updated joinedPeople array to all connected clients
    io.emit('updateJoinedPeople', joinedPeople);
    logDataStructure();
  }


  // Set a timer to periodically update the joinedPeople array
  const timer = setInterval(() => {
    updateJoinedPeople();
  }, 2000); // Update every 5 seconds

  // Socket event to handle calculate average request
  socket.on('calculateAverage', () => {
    clearInterval(timer); // Clear the timer on Calculate button click
    if (allVoted()) {
      const totalVotes = joinedPeople.length;
      const sumVotes = joinedPeople.reduce((sum, person) => sum + parseInt(person.votedValue || 0, 10), 0);
      const average = Math.round(sumVotes / totalVotes);
  
      io.emit('updateLeaderboard', joinedPeople, average);
      logDataStructure();
    } else {
      console.log('Not all users have voted.');
    }
  });

  // Disconnect event
  socket.on('disconnect', () => {
    console.log('A user disconnected');
    clearInterval(timer); // Clear the timer on disconnect
  });
});

const PORT = process.env.PORT || 3000;
server.listen(PORT, () => {
  console.log(`Server running on http://localhost:${PORT}`);
});















<!-- views/join-ui.ejs -->

<!DOCTYPE html>
<html lang="en">

<head>
    <title>Join UI</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-4bw+/aepP/YC94hEpVNVgiZdgIC5+VKNBQNGCHeKRQN+PtmoHDEXuppvnDJzQIu9" crossorigin="anonymous">
    <style>
        /* Add your custom styles here */
        body {
            background-color: #928888b0; /* Light grey background color */
            display: flex;
        }

        .left-container {
            width: 70%;
            padding: 40px;
        }

        .right-container {
            width: 30%;
            padding: 40px;
            background-color: #fff; /* White background color for the right container */
            height: 100vh; /* Take the full height of the screen */
        }

        /* Example styles for the tiles using provided secondary button styles */
        .tile-container {
            display: flex;
            flex-wrap: wrap;
            margin: -20px; /* Negative margin to counteract the margin on tiles */
        }

        .tile {
            width: calc(30% - 20px); /* Adjusted width and margin for smaller tiles */
            height: 0;
            padding-bottom: calc(30% - 20px); /* Adjusted padding for smaller tiles */
            border-radius: 6px;
            margin: 20px; /* Adjusted margin for spacing between tiles */
            display: inline-block;
            text-align: center;
            line-height: 60px; /* Adjusted line-height for smaller tiles */
            cursor: pointer;
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            background: #FFF;
            color: #FFA000;
            border: 1px solid #FFF;
            box-shadow: 0 2px 6px 0 rgba(0, 0, 0, 0.26);
            font-size: 1.5em; /* Increased font size for better visibility */
            padding: 24px; /* Added padding for better spacing within tiles */
        }

        .tile:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px 0 rgba(0, 0, 0, 0.26);
        }

        .tile:active {
            transform: scale(0.95);
            box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.26);
        }

        /* Additional styles for the input form */
        .input-container {
            width: 400px;
            margin-top: 30px;
            margin-bottom: 60px;
            display: flex;
            align-items: center;
        }

        .input-container input {
            margin-right: 10px;
        }

        /* Added style for smaller tiles */
        .small-tile {
            width: calc(10% - 20px);
            height: 0;
            padding-bottom: calc(10% - 20px);
            line-height: 30px;
            font-size: 1em;
            margin: 12px;
        }

        /* Styles for the right container */
        .right-container button,
        .right-container .leaderboard,
        .right-container .calculate-button,
        .right-container .random-number {
            margin-bottom: 20px;
            font-size: 1.2em;
        }

        .leaderboard {
            list-style-type: none;
            padding: 0;
        }

        .leaderboard th, .leaderboard td {
            text-align: left;
            padding: 10px;
        }

        .leaderboard tr:nth-child(even) {
            background-color: #f2f2f2;
        }

        .random-number {
            font-size: 2em;
            color: #4285F4; /* Blue color for the random number */
        }

        .voted-value-column {
            display: none; /* Initially hide the Voted Value column */
        }
    </style>
</head>

<body>
    <div class="left-container">
        <h2>User Interface</h2>

        <!-- Sequence type buttons -->
        <div class="btn-group" role="group" aria-label="Sequence Type">
            <button type="button" class="btn btn-secondary" onclick="updateSequences('tShirtSizes')">T-Shirt</button>
            <button type="button" class="btn btn-secondary" onclick="updateSequences('sequence1')">Seq 1</button>
            <button type="button" class="btn btn-secondary" onclick="updateSequences('sequence2')">Seq 2</button>
            <button type="button" class="btn btn-secondary" onclick="updateSequences('fibonacci')">Fibonacci</button>
            <button type="button" class="btn btn-secondary" onclick="updateSequences('custom')">Custom</button>
        </div>

        <!-- Input form for custom sequence and update button -->
        <div class="input-container">
            <input type="text" id="sequenceInput" class="form-control" placeholder="Enter a value">
        </div>

        <div id="tileContainer" class="tile-container"></div>
    </div>

    <div class="right-container">
        <table class="leaderboard" id="leaderboard">
            <thead>
                <tr>
                    <th>Joiner Name</th>
                    <th>Voted</th>
                    <th class="voted-value-column">Voted Value</th>
                </tr>
            </thead>
            <tbody>
                <% joinedPeople.forEach(person => { %>
                    <tr>
                        <td><%= person.joinerName %></td>
                        <td><%= person.voted ? '✅' : '❌' %></td>
                        <td class="voted-value-column"><%= person.votedValue %></td>
                    </tr>
                <% }); %>
            </tbody>
        </table>

        <button class="btn btn-primary" onclick="submitForm()" id="submitButton" disabled>Submit</button>

        <button class="btn btn-success calculate-button" onclick="calculateAverage()" id="calculateButton" disabled>Calculate</button>
        <div class="random-number" id="randomNumber"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.2.0/socket.io.js"></script>
    <script>
        const socket = io();
      
        // Function to update sequences based on user input
        function updateSequences(type) {
          const inputValue = document.getElementById('sequenceInput').value;
          socket.emit('updateSequences', { type, inputValue });
        }
      
        socket.on('updatedSequence', (updatedSequence) => {
          const tileContainer = document.getElementById('tileContainer');
          tileContainer.innerHTML = ''; // Clear previous content
      
          updatedSequence.forEach((value) => {
            const tile = document.createElement('div');
            tile.classList.add('tile', 'small-tile'); // Add 'small-tile' class for smaller tiles
            tile.innerText = value;
      
            // Add click event listener
            tile.addEventListener('click', () => {
              // Emit the clicked value to the server
              socket.emit('tileClicked', value);
            });
      
            tileContainer.appendChild(tile);
          });
      
          // Enable the submit button once tiles are populated
          document.getElementById('submitButton').disabled = false;
          document.getElementById('calculateButton').disabled = true; // Disable calculate button initially
        });
      
        // Frontend functions to handle the right container actions
        function submitForm() {
          // You can handle the form submission logic here
          document.getElementById('calculateButton').disabled = !canEnableCalculateButton(); // Enable/disable calculate button based on constraint
      
          // Add or remove 'voted-value-column' class based on the Calculate button state
          const votedValueColumns = document.querySelectorAll('.voted-value-column');
          votedValueColumns.forEach(column => {
            if (document.getElementById('calculateButton').disabled) {
              column.style.display = 'table-cell'; // Show the Voted Value column
            } else {
              column.style.display = 'none'; // Hide the Voted Value column
            }
          });
        }
      
        function calculateAverage() {
          // Emit a request to the backend to calculate the average
          socket.emit('calculateAverage');
          document.getElementById('calculateButton').disabled = true; // Disable calculate button after pressing
        }
      
        // Socket event to handle the leaderboard and random number update
        socket.on('updateLeaderboard', (updatedJoinedPeople, randomNumber, showVotedValueColumn) => {
            const leaderboardBody = document.querySelector('#leaderboard tbody');
            leaderboardBody.innerHTML = ''; // Clear previous content

            // Enable leaderboard only if the Submit button is pressed
            const submitButton = document.getElementById('submitButton');
            if (!submitButton.disabled) {
                updatedJoinedPeople.forEach((person) => {
                const row = document.createElement('tr');
                row.innerHTML = `<td>${person.joinerName}</td><td>${person.voted ? '✅' : '❌'}</td><td ${showVotedValueColumn ? 'class="voted-value-column"' : ''}>${person.voted ? person.votedValue : ''}</td>`;
                leaderboardBody.appendChild(row);
                });

                // Display the random number
                document.getElementById('randomNumber').innerText = `Random Number: ${randomNumber}`;
            }
        });

      
        // Handle the 'updateJoinedPeople' event to update the UI with the latest joinedPeople data
        socket.on('updateJoinedPeople', (updatedJoinedPeople) => {
          const leaderboardBody = document.querySelector('#leaderboard tbody');
          leaderboardBody.innerHTML = ''; // Clear previous content
      
          updatedJoinedPeople.forEach((person) => {
            const row = document.createElement('tr');
            row.innerHTML = `<td>${person.joinerName}</td><td>${person.voted ? '✅' : '❌'}</td><td ${person.voted ? 'class="voted-value-column"' : ''}>${person.voted ? person.votedValue : ''}</td>`;
            leaderboardBody.appendChild(row);
          });
        });
      
        // Function to check the constraint for enabling the calculate button
        function canEnableCalculateButton() {
          // You can add your constraint logic here
          return true; // For now, it's always enabled
        }
      </script>
</body>

</html>






































ok in this case, we created this fro the whole backend fucntionality right. it consists of some frontends yes but mainly it is the backend.

in the other project is fully relasted to the frontend and it also contains a bacckend. so we have to merge the both in this case ok. 



I will give the finalized backend focused part now. 

// index.js
const express = require('express');
const { createServer } = require('http');
const { createClient } = require('@supabase/supabase-js');
const { v4: uuidv4 } = require('uuid');
const bodyParser = require('body-parser');

const app = express();
const server = createServer(app);

app.use(bodyParser.urlencoded({ extended: true })); // Use body-parser middleware
app.use(bodyParser.json()); // Parse JSON bodies

const supabaseUrl = 'https://zqjmkicfcolipzkqvslv.supabase.co';
const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inpxam1raWNmY29saXB6a3F2c2x2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3MDg4NjA2MDYsImV4cCI6MjAyNDQzNjYwNn0.okYMPvmrR8ftOXIyHYIJ2DQ-Tk2ZfVZhHXMM6cBmaVk';
const supabase = createClient(supabaseUrl, supabaseKey);

app.set('view engine', 'ejs');
app.use(express.static('public'));
app.use(express.urlencoded({ extended: true }));

const port = process.env.PORT || 3000;
const sseClients = [];

app.use((req, res, next) => {
  res.sseSetup = () => {
    res.setHeader('Content-Type', 'text/event-stream');
    res.setHeader('Cache-Control', 'no-cache');
    res.setHeader('Connection', 'keep-alive');
    res.flushHeaders();
  };

  res.sseSend = (data) => {
    res.write(`data: ${JSON.stringify(data)}\n\n`);
  };

  next();
});

app.get('/sse', (req, res) => {
  res.sseSetup();

  // Add the new client to the clients array
  sseClients.push(res);

  // Remove the client when the connection is closed
  req.on('close', () => {
    const index = sseClients.indexOf(res);
    if (index !== -1) {
      sseClients.splice(index, 1);
    }
  });
});

// gets
app.get('/', (req, res) => {
  res.render('init');
});

app.get('/create-room', (req, res) => {
  res.render('create-room');
});

app.get('/join-room', (req, res) => {
  res.render('join-room');
});

app.get('/admin-ui/:username', async (req, res) => {
  const { username } = req.params;

  try {
    // Fetch the room data for the specified username
    const { data: roomData, error: roomError } = await supabase
      .from('rooms')
      .select()
      .eq('room_creator_username', username)
      .single();

    if (roomError) {
      throw new Error(`Error fetching room data: ${roomError.message}`);
    }

    // Render the admin-ui.ejs with the entire room row data
    res.render('admin-ui', { username, roomData });
  } catch (error) {
    console.error(error);
    res.status(500).send(`Error: ${error.message}`);
  }
});

app.get('/join-ui/:username', async (req, res) => {
  const { username } = req.params;

  try {
    // Fetch the room data using the provided username
    const { data: roomData, error: roomError } = await supabase
      .from('rooms')
      .select()
      .eq('room_creator_username', username)
      .single();

    if (roomError) {
      throw new Error(`Error fetching room data: ${roomError.message}`);
    }

    // Render the join-ui.ejs with the entire room row data
    res.render('join-ui', { username, roomData });
  } catch (error) {
    console.error(error);
    res.status(500).send(`Error: ${error.message}`);
  }
});

app.post('/create-room', async (req, res) => {
  const { username } = req.body;

  // Generate a valid UUID for room_creator_id
  const roomCreatorId = uuidv4();

  // Create a row for the room with essential information
  const roomData = {
    room_url: `http://localhost:3000/join-room?username=${username}&url=${username}`,
    room_creator_username: username,
    room_creator_id: roomCreatorId,
    joiners: JSON.stringify({}), // Empty for now, will be updated when joiners join
  };

  // Store the room data in the Supabase table
  const { data: createdRoom, error } = await supabase
    .from('rooms')
    .upsert([roomData], { returning: ['*'] });

  if (error) {
    console.error(error);
    res.status(500).send('Error creating room');
    return;
  }

  // Redirect to admin UI with the generated URL
  res.redirect(`/admin-ui/${username}`);
});

app.post('/join-room', async (req, res) => {
  const { username, url } = req.body;

  try {
    // Get the existing room data using the room_url
    const { data: roomData, error: roomError } = await supabase
      .from('rooms')
      .select()
      .eq('room_url', url)
      .single();

    if (roomError) {
      throw new Error(`Error fetching room data: ${roomError.message}`);
    }

    // Parse the joiners column data
    const joinersData = JSON.parse(roomData.joiners);

    // Check if the username already exists in joinersData
    if (joinersData.hasOwnProperty(username)) {
      // If the username exists, retrieve messages
      const userMessages = joinersData[username].messages;

      // Render the join-ui.ejs with existing user data
      res.render('join-ui', { username, userMessages, roomData });

      // Notify all clients about the new joiner
      // Notify all clients about the new joiner with username and URL

      console.log(url);
      sseClients.forEach(client => {
        client.sseSend({ action: 'newJoiner', username, url });
      });

    } else {
      // If the username doesn't exist, create a new entry
      // Create a unique key for the new joiner
      const joinerKey = `${username}`;

      // Add the new joiner to the joinersData with an empty array for messages
      joinersData[joinerKey] = {
        joined_at: new Date().toISOString(),
        messages: [],
      };

      // Update the joiners column in the Supabase table using the room_url
      const { data: updatedRoom, updateError } = await supabase
        .from('rooms')
        .update({ joiners: JSON.stringify(joinersData) }) // Update the joiners column
        .eq('room_url', url)
        .single();

      if (updateError) {
        throw new Error(`Error updating room data: ${updateError.message}`);
      }

      // Render the join-ui.ejs with new user data
      res.render('join-ui', { username, userMessages: [], roomData });

      // Notify all clients about the new joiner
      sseClients.forEach(client => {
        client.sseSend({ action: 'newJoiner', username });
      });
    }
  } catch (error) {
    console.error(error);
    res.status(500).send(`Error: ${error.message}`);
  }
});

app.post('/send-join-message', async (req, res) => {
  try {
    const { username, joinMessage, roomData } = req.body;

    // Parse the roomData JSON string back to an object
    const parsedRoomData = JSON.parse(roomData);

    // Retrieve the existing room data using the room_url
    const { data: roomDataFromSupabase, error: roomError } = await supabase
      .from('rooms')
      .select()
      .eq('room_url', parsedRoomData.room_url)
      .single();

    if (roomError) {
      throw new Error(`Error fetching room data from Supabase: ${roomError.message}`);
    }

    // Parse the joiners column data
    const joinersData = JSON.parse(roomDataFromSupabase.joiners);

    // Check if the username already exists in joinersData
    if (joinersData.hasOwnProperty(username)) {
      // Update the messages array for the specific user
      joinersData[username].messages.push(joinMessage);

      // Update the joiners column in the Supabase table using the room_url
      const { data: updatedRoom, updateError } = await supabase
        .from('rooms')
        .update({ joiners: JSON.stringify(joinersData) }) // Update the joiners column
        .eq('room_url', parsedRoomData.room_url)
        .single();

      if (updateError) {
        throw new Error(`Error updating room data in Supabase: ${updateError.message}`);
      }

      // Broadcast the updated joiners structure to all clients
      const updatedJoinersStructure = createJoinersStructure(joinersData);
      broadcastToClients({
        action: 'updateJoiners',
        joinersStructure: updatedJoinersStructure,
        url: parsedRoomData.room_url,
        roomCreator: parsedRoomData.room_creator_username,
      });

      // Render the join-ui.ejs with updated user data
      res.render('join-ui', { username, userMessages: joinersData[username].messages, roomData: parsedRoomData });

    } else {
      throw new Error(`User ${username} not found in joinersData`);
    }
  } catch (error) {
    console.error(error);
    res.status(500).send('Error processing message');
  }
});

app.post('/send-admin-message', async (req, res) => {
  try {
    const { username, sequenceInput } = req.body;

    // Fetch the existing room data
    const { data: existingRoom, error: fetchError } = await supabase
      .from('rooms')
      .select('sequence')
      .eq('room_creator_username', username)
      .single();

    if (fetchError) {
      throw new Error(`Error fetching room data from Supabase: ${fetchError.message}`);
    }

    // Append the new sequence message to the existing sequence
    const updatedSequence = sequenceInput;

    // Update the sequence column in the Supabase table using the room_creator_username
    const { data: updatedRoom, updateError } = await supabase
      .from('rooms')
      .update({ sequence: updatedSequence }) // Update the sequence column
      .eq('room_creator_username', username)
      .single();

    if (updateError) {
      throw new Error(`Error updating room data in Supabase: ${updateError.message}`);
    }

    // Broadcast the updated sequence to all clients
    broadcastToClients({
      action: 'updateSequence',
      sequence: updatedRoom.sequence,
      url: updatedRoom.room_url,
      roomCreator: updatedRoom.room_creator_username,
    });

    // Render the admin-ui.ejs with updated data
    // res.render('admin-ui', { username, roomData: updatedRoom });

    // Broadcast the updated joiners structure to all clients
    const updatedJoinersStructure = createJoinersStructure(JSON.parse(updatedRoom.joiners));
    broadcastToClients({
      action: 'updateJoiners',
      joinersStructure: updatedJoinersStructure,
      url: updatedRoom.room_url,
      roomCreator: updatedRoom.room_creator_username,
    });

    // Return here to avoid the "headers already sent" error
    return;
  } catch (error) {
    console.error(error);
    res.status(500).send('Error processing admin message');
  }
});



// Helper function to create the desired structure from joinersData
function createJoinersStructure(joinersData) {
  return Object.keys(joinersData).map((joinerKey) => {
    const joiner = joinersData[joinerKey];
    return {
      joinerName: joinerKey,
      joinerId: joinerKey.split('-')[1], // Extracting the joiner ID from the key
      voted: joiner.messages.length > 0, // If messages array is not empty, voted is true
      votedValue: joiner.messages.length > 0 ? joiner.messages[joiner.messages.length - 1] : '', // Latest message as votedValue
    };
  });
}

// Helper function to broadcast data to all connected clients
function broadcastToClients(data) {
  sseClients.forEach(client => {
    client.sseSend(data);
  });
}

async function createTableIfNotExists(table_name) {
  // Create the query to create a new table with a predefined schema
  const query = `CREATE TABLE IF NOT EXISTS ${table_name} (id SERIAL PRIMARY KEY, username TEXT NOT NULL, message TEXT NOT NULL)`;

  // Execute the query
  await supabase.rpc('create_new_table', { table_name: table_name });
}

async function checkTableExists(table_name) {
  // Check if the table exists
  const { data, error } = await supabase
    .from('rooms')
    .select()
    .eq('room_name', table_name)
    .single();

  return data !== null;
}

app.post('/send-message', async (req, res) => {
  const { username, message } = req.body;

  // Store the message in the Superbase table
  const { data, error } = await supabase
    .from(username)
    .upsert([{ username, message }], { returning: ['*'] });

  if (error) {
    console.error(error);
    res.status(500).send('Error storing message');
    return;
  }

  res.redirect(`/admin-ui/${username}`);
});

server.listen(port, () => {
  console.log(`Server is running on http://localhost:${port}`);
});









<!-- views/join-ui.ejs -->
<!DOCTYPE html>
<html lang="en">

<head>
  <!-- ... (head section remains unchanged) ... -->
</head>

<body>
  <h1>Welcome <%= username %> to the Join UI</h1>

  <!-- Display User Details -->
  <h2>User Details:</h2>
  <p>Username: <%= username %>
  </p>
  <!-- Display Room Data -->
  <p>Room URL: <%= roomData.room_url %>
  </p>
  <p>Room Owne: <%= roomData.room_creator_username %>
  </p>
  <p>Joiners: <%= roomData.joiners %>
  </p>
  <p>Sequence: <%= roomData.sequence %>
  </p>

  <!-- Display User Messages -->
  <h2>User Messages:</h2>
  <ul>
    <% userMessages.forEach((message)=> { %>
      <li>
        <%= message %>
      </li>
      <% }); %>
  </ul>

  <!-- Messaging Form -->
  <form id="joinForm" action="/send-join-message" method="POST">
    <!-- Hidden input fields to include room data and username -->
    <input type="hidden" name="roomData" value='<%= JSON.stringify(roomData) %>'>
    <input type="hidden" name="username" value='<%= username %>'>

    <label for="joinMessage">Enter Message:</label>
    <input type="text" id="joinMessage" name="joinMessage" required>
    <button type="submit">Send</button>
  </form>

  <!-- Display Join Messages -->
  <ul id="joinMessages">
    <% userMessages.forEach((message)=> { %>
      <li>
        <%= message %>
      </li>
      <% }); %>
  </ul>

  <p>Sequence: <%= roomData.sequence %></p>

  <script>
    // Use JavaScript to handle form submission asynchronously
    document.addEventListener('DOMContentLoaded', () => {
      const joinForm = document.getElementById('joinForm');

      joinForm.addEventListener('submit', async (event) => {
        event.preventDefault(); // Prevent the default form submission behavior

        const formData = new FormData(joinForm);
        const joinMessage = formData.get('joinMessage');
        const roomData = formData.get('roomData');
        const username = formData.get('username');

        try {
          const response = await fetch('/send-join-message', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({ username, joinMessage, roomData }),
          });

          if (!response.ok) {
            throw new Error(`Error sending join message: ${response.statusText}`);
          }

          console.log('Join message sent successfully.');

          // You can perform additional actions based on the response if needed

        } catch (error) {
          console.error(`Error sending join message: ${error.message}`);
        }
      });
    });

  </script>
  <script>
    function decodeHtmlEntities(html) {
      var txt = document.createElement('textarea');
      txt.innerHTML = html;
      return txt.value;
    }

    const eventSource = new EventSource('/sse');


  // SSE event listener for handling 'updateJoiners' event
  eventSource.onmessage = async (event) => {
    const eventData = JSON.parse(event.data);
    
    switch (eventData.action) {
      case 'newJoiner':
        console.log(`New joiner option`);
        if (eventData.url === decodeHtmlEntities('<%= roomData.room_url %>')) {
          console.log(`New joiner: ${eventData.username}`);

          // Retry fetching the updated roomData after a timeout if it's still undefined
          if (!roomData) {
            await new Promise(resolve => setTimeout(resolve, 4000)); // 4 seconds timeout
            // Fetch the updated room data here
            // roomData = ...
            console.log('Retrying to fetch updated roomData after timeout...');

            // If roomData is still undefined after the timeout, you can handle it accordingly
            if (!roomData) {
              console.log('Room data is still undefined after timeout.');
              return;
            }
          }

          // Now you can use the updated roomData
          console.log('Using updated roomData:', roomData);
        } else {
          console.log(`Not equal: ${eventData.url} and <%= roomData.room_url %>`);
        }
        break;

      case 'updateJoiners':
        console.log(`Updating joiners structure for room: ${eventData.url}`);
        console.log(`Room Creator: ${eventData.roomCreator}`);
        console.log('Updated Joiners Structure:', eventData.joinersStructure);
        // Update the UI with the new joiners structure
        updateJoinersStructure(eventData.joinersStructure);
        break;

      default:
        console.log(`Unknown action: ${eventData.action}`);
        break;
    }
  };






    // Function to update the UI with the new joiners structure
    function updateJoinersStructure(joinersStructure) {
      // Clear the existing joiners list
      const joinersList = document.getElementById('joinersList');
      joinersList.innerHTML = '';

      // Iterate through the new joiners structure and append to the list
      joinersStructure.forEach((joiner) => {
        const listItem = document.createElement('li');
        listItem.innerHTML = `Joiner Name: ${joiner.joinerName}, Joiner ID: ${joiner.joinerId}, Voted: ${joiner.voted}, Voted Value: ${joiner.votedValue}`;
        joinersList.appendChild(listItem);
      });
    }

    eventSource.onerror = (error) => {
      console.error('SSE Error:', error);
      eventSource.close();
    };
  </script>
</body>

</html>














<!-- views/join-room.ejs -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Join Room</title>
</head>
<body>
  <h1>Join Room</h1>
  <form action="/join-room" method="POST">
    <label for="username">Your Name:</label>
    <input type="text" id="username" name="username" required>
    <label for="url">Room URL:</label>
    <input type="text" id="url" name="url" required>
    <button type="submit">Join Room</button>
  </form>
</body>
</html>














<!-- views/init.ejs -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Voting System</title>
</head>
<body>
  <h1>Welcome to the Voting System</h1>
  <a href="/create-room">Create Room</a>
  <a href="/join-room">Join Room</a>
</body>
</html>


















<!-- views/create-room.ejs -->
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Create Room</title>
</head>

<body>
  <h1>Create Room</h1>
  <form action="/create-room" method="POST">
    <label for="username">Your Name:</label>
    <input type="text" id="username" name="username" required>
    <button type="submit">Create Room</button>
  </form>
</body>

</html>















<!-- views/admin-ui.ejs -->
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Admin UI</title>
</head>

<body>
  <h1>Welcome <%= username %> to the Admin UI</h1>

  <!-- Room Details -->
  <p>This is Admin's room</p>
  <p>Admin: <%= username %>
  </p>

  <p>Room URL: <%= roomData.room_url %>
  </p>
  <p>Room Creator: <%= roomData.room_creator_username %>
  </p>
  <p>Joiners: <%= roomData.joiners %>
  </p>
  <p>Sequence: <%= roomData.sequence %>
  </p>

  <p>Sequence got from the databse after submission: <%= roomData.sequence %>
  </p>
  <!-- Copy URL Button -->
  <button onclick="copyToClipboard('<%= roomData.room_url %>')">Copy URL</button>

  <!-- Admin Message Form -->
  <form id="adminMessageForm" action="/send-admin-message" method="POST">
    <label for="sequenceInput">Sequence Input:</label>
    <input type="text" id="sequenceInput" name="sequenceInput" required>
    <button type="submit">Send</button>
  </form>

  <!-- Display Messages -->
  <ul id="messages"></ul>

  <script>
    // Use JavaScript to handle admin message form submission asynchronously
    document.addEventListener('DOMContentLoaded', () => {
      const adminMessageForm = document.getElementById('adminMessageForm');

      adminMessageForm.addEventListener('submit', async (event) => {
        event.preventDefault(); // Prevent the default form submission behavior

        const formData = new FormData(adminMessageForm);
        const sequenceInput = formData.get('sequenceInput');

        try {
          const response = await fetch('/send-admin-message', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({ username: '<%= username %>', sequenceInput }),
          });

          if (!response.ok) {
            throw new Error(`Error sending admin message: ${response.statusText}`);
          }

          console.log('Admin message sent successfully.');

          // You can perform additional actions based on the response if needed

        } catch (error) {
          console.error(`Error sending admin message: ${error.message}`);
        }
      });
    });


    // Function to copy URL to clipboard
    function copyToClipboard(url) {
      const el = document.createElement('textarea');
      el.value = url;
      document.body.appendChild(el);
      el.select();
      document.execCommand('copy');
      document.body.removeChild(el);
      // alert('URL copied to clipboard!');
    }
  </script>
  <script>
    function decodeHtmlEntities(html) {
      var txt = document.createElement('textarea');
      txt.innerHTML = html;
      return txt.value;
    }

    const eventSource = new EventSource('/sse');

    eventSource.onmessage = async (event) => {
      const eventData = JSON.parse(event.data);

      switch (eventData.action) {
        case 'newJoiner':
          console.log(`New joiner option`);
          if (eventData.url === decodeHtmlEntities('<%= roomData.room_url %>')) {
            console.log(`New joiner: ${eventData.username}`);

            // Retry fetching the updated roomData after a timeout if it's still undefined
            if (!roomData) {
              await new Promise(resolve => setTimeout(resolve, 4000)); // 4 seconds timeout
              // Fetch the updated room data here
              // roomData = ...
              console.log('Retrying to fetch updated roomData after timeout...');

              // If roomData is still undefined after the timeout, you can handle it accordingly
              if (!roomData) {
                console.log('Room data is still undefined after timeout.');
                return;
              }
            }

            // Now you can use the updated roomData
            console.log('Using updated roomData:', roomData);
          } else {
            console.log(`Not equal: ${eventData.url} and <%= roomData.room_url %>`);
          }
          break;

        case 'updateJoiners':
          console.log(`Updating joiners structure for room: ${eventData.url}`);
          console.log(`Room Creator: ${eventData.roomCreator}`);
          console.log('Updated Joiners Structure:', eventData.joinersStructure);
          // Update the UI with the new joiners structure
          updateJoinersStructure(eventData.joinersStructure);
          break;

        case 'updateSequence':
          console.log(`Updating sequence for room: ${eventData.url}`);
          console.log(`Room Creator: ${eventData.roomCreator}`);
          console.log('Updated Sequence:', eventData.sequence);

          // Update the UI with the new sequence information
          updateSequence(eventData.sequence);
          break;
        default:
          console.log(`Unknown action: ${eventData.action}`);
          break;
      }
    };


    // Function to update the UI with the new joiners structure
    function updateJoinersStructure(joinersStructure) {
      // Clear the existing joiners list
      const joinersList = document.getElementById('joinersList');
      joinersList.innerHTML = '';

      // Iterate through the new joiners structure and append to the list
      joinersStructure.forEach((joiner) => {
        const listItem = document.createElement('li');
        listItem.innerHTML = `Joiner Name: ${joiner.joinerName}, Joiner ID: ${joiner.joinerId}, Voted: ${joiner.voted}, Voted Value: ${joiner.votedValue}`;
        joinersList.appendChild(listItem);
      });
    }

    // Function to update the UI with the new sequence information
    function updateSequence(sequence) {
      // Update the sequence in your UI
      const sequenceElement = document.getElementById('sequence');
      if (sequenceElement) {
        sequenceElement.innerText = `Sequence: ${sequence}`;
      }
    }

    eventSource.onerror = (error) => {
      console.error('SSE Error:', error);
      eventSource.close();
    };
  </script>

</body>

</html>









OK, both of these cores have a particular kind of coherence, a particular kind of relationship. That is like this. Basically, you know in the first core that we in this ChatGP worked on, it is about creating a room and everything in the back-end level. So basically, a particular person can get into the Create Room option, and there he can specify a username, and then he can create a room. A new room will be created. That is the room. And in it, his username, URL, joiners column, sequence, IDs, and other stuff will be there. At the same time, a new URL will be created. That URL can be copied to the clipboard at the admin's level. This admin can share that to any person, and also, he can type a sequence, and then he can send that. This sequence will be stored on that particular row on the sequence column as well. Then, just after that, that particular sequence will be broadcasted as an event, because we used SSC method. So then, admin's UI will be updated after that with this sequence. So basically, this sequence will be at the admin's level after that. So we can see the sequence on his UI as a label. Then, when joiners joins him, we know that this joiners got this URL, and they got the path join room option. In there, they can specify their username, and this URL can be given. And then, press join room. Then, he will be taken into the same room. And under this particular table named rooms, we check for the exact URL. One is the exact room, and in it, we can find joiners column. And in this joiners column, we got all the members. And this particular new joiner, as well, will be taken into this particular exact joiners JSON, and he will be placed there as an event. And then, messages array will be created for that person as well. If this particular person's name is already existing in this particular JSON, we do not create a new entry for that person. We consider.

Okay, if joiner's name is on the joiner's JSON, that means he's already existing there. In that case, he will not be added as a new member. Instead, the existing data related to this particular member will be used in all the cases. Otherwise, he will be added as a new entry. That is my point. Then, once this particular person is added or verified that he's already in the JSON, a new page named JoinUI.js will be created. And in this particular UI, we include all the data related to this particular new joiner or the existing joiner-related data will be shown there. That includes the sequence that this admin created and row-related data such as URL, room owner's name, and all the messages.

Okay. Now, this particular person can send a message, and this message will be taken to the database through the backend.
Once a new joiner joins in, he can send messages. These messages will be taken to the backend and then these messages will be taken to the database as well. Then in the database, in the table rooms under that particular row related to this specific row, in the JSON file under his particular name, we save this message in the chronological order. So basically the latest message is at the end of the array. Then we also take this newly updated array,

Then we basically do another event, we get all the messages and we send all the messages to the AOL people and also at the client side we do a check whether the URL of the joiner or the admin, basically the whole room, is equal to the received message related URL. If so, we consider that this message or these data records are related to this URL.

































Now I will explain what I want at the end product using both of these projects. First, basically, the idea is something like this. This is a voting system, a real-time voting system using service and events method instead of so-called IOP. So basically, what happens is when a new room creator joins into this system, he gets to the create room option, and at the create room option, he can input a username, and then a new UI will be created. So in this UI, basically, I want to show all the data, the whole UI that we have got in the second project that I gave to you related to the frontend. So basically, it should consist the user interface, that should be admin view, and then the sequence selection bar should be there, and then text form field should be there, then those tiles that we populate should be there, the 30%, 70% width difference should be there. In the 30% side, we should show that leaderboard, and the buttons, and everything. Those stuff should be shown in the admin view instead of the current one. I want all the data, all the implementation in the current page into this new, the colorful UI, and I want to get that copy URL button as well. So basically, after this implementation is done, the admin UI is this. Basically, this admin UI should consist of his name and admin room as a H1 tag, then a sequence selection bar, and a text form field to enter the value, or the sequence using comma separated, as a comma separated string, then we create a custom string, custom sequence, and then we need that submit button, calculate button, the leaderboard, and everything should be there as exactly as it is. It also should work exactly as it does right now. So then, what this admin does is, he copies the URL and shares it with other people. So basically, this copy URL button also should be there in this exact UI. So next to sequence selection bar, in the horizontal side, in line, there's this copy URL button as well. Then this person can copy this particular URL, and he can share that with the other people. So if he wants to join us, he wants to join into this particular group, then he can select a sequence, basically, he can enter a value on the text form field and press the button on the sequence bar, or just press the button on the sequence bar, and those example sequences on the back end will be used in that case. In both cases, we know that those trials are populated. After those trials are populated, that means we already have selected the sequence, then this person can press the submit button.

When we press this submit button, it should do the same work that admin-related text form field and send message part does. Basically, we use that to send the sequence to the backend and then to the database. So basically, admin sending a message means in the original code that in the backend-related code, the admin sent a message means that it's the sequence. So what we did was we took that particular message and we saved that in the database under sequence column. In this particular context as well, once the admin select a particular sequence by any means, once the tiles are populated, that means we already have selected a particular sequence, then he can press the submit button. At that level, we should do that send him admin message to the backend part. So the whole sequence we selected should go to the backend and it should be stored in the superbase database on the sequence column. Then the sequence selection part is done. Then we know that the whole sequence is broadcasted using an event. Then those tasks should happen exactly as they did so far. Basically, I want to replace this admin sending message to the backend part with this sequence selection option. So at the end, the selected sequence is the message this admin sends to the backend. That is the replacement. So instead of a text form field and a send button, now we use a sequence selection bar, a text form field to get the upper margin of the sequence. Once this person selects a particular sequence of any type, a custom, a Fibonacci or a sequence or a t-shirt sizes or anything, he can decide to press the submit button. Once the submit button is pressed, the exact thing that we did using the admin related text form field and the button, basically sending a message to the backend as an admin happens and that particular sequence that we created is stored in the sequence column in the database. That is the exact behavior that I want to do in this level. I will give the next parts in the next chat.

Okay, now we know that this admin's UI can set the sequence in this manner. Then he can copy the URL. I'll come to the admin's UI later because admin's UI consists of a lot of more functionalities than this. I'll cover them in a particular order because you can realize that this is the exact behavior that I am expecting. So I'll get to the admin's UI later. For the rest of the work, for now, keep in mind that we can copy the URL by pressing this copy URL button on the admin's UI. So the admin can copy this URL and he can share that with other people he wants to share this with. Then those people can join into this system. We know for that we used to join a ui.ejs. In there, basically what happens is once a person gets the URL, he can get into the init.ejs and through that he can get to the create room or join room option. The joiner should go to the join room option and there he or she can specify a username and then he can paste the URL as exactly as it is and then he can press the join room button and he will be taken to this exact room that we created. At that level, we know that already the admin has stored the sequence in the database. Also, in the get method of the join ui.ejs, we send this sequence to the join ui.ejs as well through the get method props. So then you should populate the exact tiles set which we populated at the admin UI as it is. Basically, you should create the exact same admin UI on this user, basically joiner ui.ejs as well, but you should remove these parts. Sequence selection bar, the test form field to add the upper margin of the sequence and the copy URL button. All three of them should not be there. Also, the buttons related to submit and calculate should be taken away. Only the header one with joiner's name and join room after this particular prefix should be there. Then the tiles should be populated there.

No, no, no. You missed something, actually. In the join-ui.tjs, you should only show the header1 field with joiner's exact username and then add a text like a room or something, okay? It's only a header1 field with a variable. Then below to that, the exact level that use this admin UI created, the tiles should be populated in the 70% width to the left-aligned one, and then in the right side, in the 30%, you should show the leaderboard with two columns, as we already did in the previous case, and that is it. No other buttons or anything. He only can press a tile, and once a tile is pressed, that means we know that we already have selected the particular sequence, and that sequence is stored in the backend, basically in the database, actually. So this database-stored sequence is used to populate this tile set as a list to you. If this person presses a particular tile, that means that is what he wants. That is what he intended to choose.

Now we know that we create this particular tile set, tile list view on the joinui.tjs using the sequence stored on the row related to this particular room on the SuperViz data table. Then you know that this person can click on any of those tiles. So if we click on tile number 10, you should consider this 10 is the message that he wants to send. So instead of this text form field that we used so far, so basically what we did was in the joinui.tjs, we had a text form field and a button. So he can fill a value, a particular string there, and he can press send button. So that particular message will be taken to the backend.

Exactly, you got it correct. So basically once a person press a particular button, press a particular tile, that exact value on this particular tile should send us the message that this joiner sent him. So it should be stored in the database under his name in the joiner's JSON.

Okay, then after any message recorded, we know that we trigger a particular event in our original code on this particular chat, not the one I gave as the GUI-related code. We know that after saving a new message, we broadcast that as an event and that exact behavior should happen in this case as well. So basically, for that, we created a data structure, right? So basically, we get the joiner-related JSON and we converted that to joiner's name, then joiner ID, then watered and watered value, likewise. So those four attributes were combined together and created a single object and using such objects, we included the latest messages of all the people within this particular row. So if someone has already watered, his watered state is true, otherwise it is false. You remember that, I assume. So basically, that exact thing should happen and then you can see in the GUI-related code that I gave to you recently, it expects something, the exact structure of the data at the front-end level to populate the leaderboard. So you should use this created data that we send event to populate this leaderboard in the admins view and all the joiners' UIs. In each of these cases, you should consider to validate that this data packet relates to this exact room that this joiner or the admin related. So basically, you should do that comparison between both URLs in all the communications between the server and the front-ends. So that is something I want to implement in this manner. So basically, once the sequence is selected, the leaderboard should be created at the admins level and the copy URL button is enabled so the admin can copy that URL and share. Then once the joiners are joined, that they can send messages. Those messages and all the stuff will be sent as events to all the people and then we filter. Then at the front-end level, we populate this particular leaderboard and initially, prior to pressing this calculate button, in all the UIs, we show only two columns, the name of the joiner and his voted or not voted state, that true or false state. And once the admin presses the calculate button, we broadcast that value as well to all the UIs and at that level, we show the voted value as well. So basically, three columns will be there at that level and that particular random number will be there. The random number calculation, I'll show you on the go when we implement this particular call.

Okay, in this particular context, I should explain something as well. Joiner-related message means his vault. He selects that by pressing a tile that we populate on his user interface. Then, admin's message is exactly the sequence he selects, using the exact same way. So, that is stored on the database. So, that you have to understand. So, please go through the whole thing that I explained to you, and explain the whole process of the end product that I want, in a high-level manner, highly detailed manner.